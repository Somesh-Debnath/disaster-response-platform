# Disaster Response Coordination Platform

A comprehensive backend system for disaster response coordination built with Spring Boot, featuring real-time social media monitoring, geospatial resource mapping, AI-powered location extraction, and official updates aggregation.

## Features

- **Disaster Management**: Full CRUD operations for disaster records with geospatial support
- **Social Media Monitoring**: Real-time monitoring of social media reports (mock implementation)
- **Geospatial Resource Mapping**: Location-based resource queries using PostGIS
- **AI Integration**: Google Gemini API for location extraction and image verification
- **Official Updates**: Web scraping of government and relief organization updates
- **Real-time Updates**: WebSocket support for live data streaming
- **Caching**: Supabase-based caching system for API responses
- **Rate Limiting**: API protection using Bucket4j

## Tech Stack

- **Backend**: Spring Boot 3.2.5, Java 17
- **Database**: PostgreSQL with PostGIS extension
- **Geospatial**: Hibernate Spatial, JTS Geometry
- **Real-time**: WebSocket (STOMP/SockJS)
- **HTTP Client**: WebFlux WebClient
- **Caching**: Supabase PostgreSQL with JSONB
- **Rate Limiting**: Bucket4j
- **Web Scraping**: Jsoup
- **Build Tool**: Maven

## Prerequisites

- Java 17 or higher
- Maven 3.6+
- PostgreSQL with PostGIS extension
- (Optional) Supabase account for production deployment

## Setup Instructions

### 1. Database Setup

#### Option A: Local PostgreSQL with PostGIS
```sql
-- Install PostGIS extension
CREATE EXTENSION IF NOT EXISTS postgis;

-- Create database
CREATE DATABASE disaster_response;
```

#### Option B: Supabase (Recommended for production)
1. Create a Supabase project at https://supabase.com
2. Enable PostGIS extension in your database
3. Get your connection details from Project Settings > Database

### 2. Configuration

Update `src/main/resources/application.properties`:

```properties
# Database Configuration
spring.datasource.url=jdbc:postgresql://your-host:5432/your-database
spring.datasource.username=your-username
spring.datasource.password=your-password

# API Keys (Optional for development)
gemini.api.key=your_gemini_api_key
google.maps.api.key=your_google_maps_key
```

### 3. Build and Run

```bash
# Navigate to project directory
cd backend/disaster

# Build the project
mvn clean install

# Run the application
mvn spring-boot:run
```

The application will start on `http://localhost:8080`

## API Endpoints

### Disasters
- `GET /api/v1/disasters` - Get all disasters
- `GET /api/v1/disasters?tag=flood` - Get disasters by tag
- `GET /api/v1/disasters/{id}` - Get disaster by ID
- `POST /api/v1/disasters` - Create new disaster
- `PUT /api/v1/disasters/{id}` - Update disaster
- `DELETE /api/v1/disasters/{id}` - Delete disaster

### Resources
- `GET /api/v1/disasters/{id}/resources` - Get resources for disaster
- `GET /api/v1/disasters/{id}/resources?lat=40.7128&lon=-74.0060&radiusKm=5.0` - Get resources near location
- `POST /api/v1/disasters/{id}/resources` - Create resource

### Social Media
- `GET /api/v1/disasters/{id}/social-media` - Get social media reports
- `GET /api/v1/disasters/{id}/social-media/mock` - Get mock social media data
- `POST /api/v1/disasters/{id}/social-media/refresh` - Refresh social media data

### Official Updates
- `GET /api/v1/disasters/{id}/official-updates` - Get official updates
- `POST /api/v1/disasters/{id}/official-updates/refresh` - Refresh official updates

### Image Verification
- `POST /api/v1/disasters/{id}/verify-image` - Verify image authenticity

### Geocoding
- `POST /api/v1/geocode` - Geocode location name
- `POST /api/v1/geocode/extract` - Extract and geocode location from text

## Testing with Postman

1. Import the `Disaster_Response_API.postman_collection.json` file into Postman
2. Set environment variables:
   - `baseUrl`: `http://localhost:8080`
   - `disasterId`: Use the ID from created disasters

### Sample Data

The application automatically creates sample data on startup:

**Sample Disasters:**
- NYC Flood Emergency (Manhattan)
- Downtown Earthquake (Downtown NYC)

**Sample Resources:**
- Red Cross Shelter (Lower East Side)
- Emergency Medical Center (East Village)
- Food Distribution Center (Manhattan)
- Building Inspection Team (Downtown)
- Emergency Response Unit (Financial District)

## WebSocket Endpoints

Connect to `ws://localhost:8080/ws` for real-time updates:

- `/topic/disasters/{id}` - Disaster updates
- `/topic/disasters/{id}/social-media` - Social media updates
- `/topic/disasters/{id}/resources` - Resource updates
- `/topic/disasters/{id}/official-updates` - Official updates

## Development Notes

### Generated by Cursor AI
This project was developed using Cursor AI for rapid development of complex backend logic, including:
- API route generation
- Geospatial query implementation
- WebSocket configuration
- Service layer architecture
- Mock data generation

### Mock Implementations
The following features use mock implementations for development:
- Social Media API (Twitter/Bluesky integration)
- Google Gemini AI (location extraction and image verification)
- Google Maps Geocoding
- Web scraping of official websites

### Production Deployment
For production deployment:
1. Replace mock implementations with real API integrations
2. Configure proper API keys
3. Set up Supabase for caching
4. Configure proper CORS settings
5. Set up monitoring and logging

## Database Schema

### Tables
- `disasters` - Disaster records with geospatial data
- `resources` - Resource locations with geospatial queries
- `reports` - User reports and images
- `cache` - API response caching with TTL

### Geospatial Features
- PostGIS geography columns for location data
- Spatial indexes for fast location-based queries
- Distance-based resource lookups

## Contributing

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Add tests
5. Submit a pull request

## License

This project is licensed under the MIT License. 